# PDF Processing and Question Answering with AWS Lambda

This project provides an AWS Lambda function that takes a PDF document and a question as input, extracts text from the document using Amazon Textract, and returns an answer to the question using a Hugging Face API model.<br>
It uses Streamlit to build the UI.<br>
Following are the steps to reproduce this project.

## Features

- **PDF Upload**: Uploads a base64-encoded PDF file to an S3 bucket.
- **Text Extraction**: Uses Amazon Textract to detect text within the PDF document.
- **Question Answering**: Calls a Hugging Face API to generate an answer to the specified question based on the extracted text.
- **S3 Cleanup**: Deletes the uploaded PDF from S3 after processing is complete.

---
## Getting started with AWS account

1. **AWS Account**: Set up an AWS account.
    - **Step 1**: Click on cloud computing services-AWS
        - <img src="IMAGES/1.png" alt="Screenshot description" width="700"/>
    - **Step 2**: Go to sign in to the console
        - <img src="IMAGES/2.png" alt="Screenshot description" width="700"/>
    - **Step 3**: Create a new AWS account and fill the details
        - <img src="IMAGES/3.png" alt="Screenshot description" width="700"/>
        - <img src="IMAGES/4.png" alt="Screenshot description" width="700"/>
    - **Step 4**: Once the account is created, sign in using root user email
        - <img src="IMAGES/5.png" alt="Screenshot description" width="700"/>
    - **Step 5**: Enter your email and password:
        - <img src="IMAGES/6.png" alt="Screenshot description" width="700"/>
        - <img src="IMAGES/7.png" alt="Screenshot description" width="700"/>


2. **S3 Bucket**: Create an S3 bucket for storing uploaded PDF files.
3. **Textract Access**: Ensure Textract permissions are enabled for the Lambda function.
4. **Hugging Face API Key**: Obtain an API key from Hugging Face to use their models.
5. **AWS Lambda Function**: Deploy the code to AWS Lambda with appropriate IAM roles and permissions for S3 and Textract.

---
## Setup

1. **Create S3 Bucket**:
   - Go to the S3 console on AWS.
      - <img src="./IMAGES/8.png" alt="Screenshot description" width="700"/>
      - <img src="./IMAGES/9.png" alt="Screenshot description" width="700"/>
   - Create a bucket (e.g., `awshugb`) and note the bucket name for use in the Lambda function.
      - <img src="./IMAGES/10.png" alt="Screenshot description" width="700"/>
      - <img src="./IMAGES/11.png" alt="Screenshot description" width="700"/>
      - Keep the default settings for creating the bucket and click on create bucket.
      - <img src="./IMAGES/12.png" alt="Screenshot description" width="700"/>

2. **Create Lambda Function**:
   - Go to the AWS Lambda console.
      - <img src="./IMAGES/13.png" alt="Screenshot description" width="700"/>
   - Click on **Create function** and choose **author from scratch**.
   - Set a function name (e.g., `TextractAndAnswerFunction`).
   - Choose Python 3.12 as the runtime.
      - <img src="./IMAGES/14.png" alt="Screenshot description" width="700"/>  
      - <img src="./IMAGES/15.png" alt="Screenshot description" width="700"/>  
   - Click on **Create function**.
      - <img src="./IMAGES/16.png" alt="Screenshot description" width="700"/>  

3. **Configure IAM Roles**:
   - Go to IAM role in console.
   - In IAM select users and click on create user.
   - Then set the username and password(either autogenerated or custom)
      - <img src="./IMAGES/17.png" alt="Screenshot description" width="700"/>
      - <img src="./IMAGES/18.png" alt="Screenshot description" width="700"/> 
      - <img src="./IMAGES/19.png" alt="Screenshot description" width="700"/>  
      - <img src="./IMAGES/20.png" alt="Screenshot description" width="700"/> 
   - In the next step you need to select **attach policies directly**(here itself you can attach policies which are described below in the next steps.)
      - <img src="./IMAGES/21.png" alt="Screenshot description" width="700"/> 
      - <img src="./IMAGES/22.png" alt="Screenshot description" width="700"/> 
   - Click on create user
      - <img src="./IMAGES/23.png" alt="Screenshot description" width="700"/> 
   - After creating IAM user go to your desired lambda function.
      - <img src="./IMAGES/24.png" alt="Screenshot description" width="700"/> 
   - In the configuration tab, click on the role link given.
      - <img src="./IMAGES/25.png" alt="Screenshot description" width="700"/>  

   - Attach the highlighted policies to this role.
      - <img src="./IMAGES/26.png" alt="Screenshot description" width="700"/>  

   - Assign this role to your Lambda function.

4. **Set Up Hugging Face API Key**:
   - Sign up or log in to [Hugging Face](https://huggingface.co/).
      - <img src="./IMAGES/27.png" alt="Screenshot description" width="700"/> 
   - After creating your account, search for your desired model, and click on it.
      - <img src="./IMAGES/28.png" alt="Screenshot description" width="700"/> 

   - Click on the Acknowledge License and Request access for the model.
      - <img src="./IMAGES/29.png" alt="Screenshot description" width="700"/> 
      - <img src="./IMAGES/30.png" alt="Screenshot description" width="700"/> 
   - Now go to Profile -> Settings, go to Access Tokens and Create new token. Once the token is created, you can use all the models whose access you have.
      - <img src="./IMAGES/31.png" alt="Screenshot description" width="700"/> 
      - <img src="./IMAGES/32.png" alt="Screenshot description" width="700"/> 
      - <img src="./IMAGES/33.jpeg" alt="Screenshot description" width="700"/> 

   - After getting the access to the model, click on deploy -> inference api, and add the model api and header in your lambda function code.
      - <img src="./IMAGES/34.jpeg" alt="Screenshot description" width="700"/> 
      - <img src="./IMAGES/35.jpeg" alt="Screenshot description" width="700"/> 

5. **Deploy Lambda Function**:
   - Go to the Lambda console and open the function you just created.
      - <img src="./IMAGES/36.png" alt="Screenshot description" width="700"/> 

   - Copy the provided Python code and paste it into the Lambda editor. Deploy the function after adding all the layers as below
   - For deploying, go to configuration tab and change the timeout as below.
      - <img src="./IMAGES/37.png" alt="Screenshot description" width="700"/> 
      - <img src="./IMAGES/44.png" alt="Screenshot description" width="700"/> 
      - <img src="./IMAGES/45.png" alt="Screenshot description" width="700"/> 

   - You need to add some layers of some libraries, for maintaining dependencies and version compatibilities.
   - For this, type the following command in the terminal to install your libraries, go to the folder where they are downloaded and compress them to zip file.
      - <img src="./IMAGES/42.jpeg" alt="Screenshot description" width="700"/> 
      - <img src="./IMAGES/43.jpeg" alt="Screenshot description" width="700"/> 
   - Add these zip files to layers in lambda function.
      - <img src="./IMAGES/38.png" alt="Screenshot description" width="700"/> 
      - <img src="./IMAGES/39.png" alt="Screenshot description" width="700"/> 
   - Add these highlighted zip files to layers in your lambda function, to replicate our code.

      - <img src="./IMAGES/40.png" alt="Screenshot description" width="700"/> 
      - <img src="./IMAGES/41.png" alt="Screenshot description" width="700"/> 


   - If necessary, add environment variables like `S3_BUCKET_NAME` for the S3 bucket.
   - Save the function.

6. **API GATEWAY CREATION TO INVOKE LAMBDA FUNCTION**:

   - In console search **API GATEWAY** -> click on create API and follow the below steps :
   
      - <img src="./IMAGES/46.jpeg" alt="Screenshot description" width="700"/> 
      - <img src="./IMAGES/47.jpeg" alt="Screenshot description" width="700"/> 
      - <img src="./IMAGES/48.jpeg" alt="Screenshot description" width="700"/> 
      - <img src="./IMAGES/49.jpeg" alt="Screenshot description" width="700"/> 
      - <img src="./IMAGES/50.jpeg" alt="Screenshot description" width="700"/> 
      - <img src="./IMAGES/52.jpeg" alt="Screenshot description" width="700"/> 

   - In API GATEWAY go to **Routes** and create a route as follow:

      - <img src="./IMAGES/53.jpeg" alt="Screenshot description" width="700"/> 
      - <img src="./IMAGES/54.jpeg" alt="Screenshot description" width="700"/> 
      - <img src="./IMAGES/55.jpeg" alt="Screenshot description" width="700"/>   

   - Then go the the **Stages** and create a stage as follow.
   - After creating the stage, one invoke URL is generated which is to be added in the web interface code given in later part of the file, which is used to invoke the lambda function whenever the request is made.
      - <img src="./IMAGES/56.jpeg" alt="Screenshot description" width="700"/> 
   
   - Again navigate to the Routes -> Attach Integration -> follow the below steps and then finally deploy it:

      - <img src="./IMAGES/57.jpeg" alt="Screenshot description" width="700"/> 
      - <img src="./IMAGES/58.jpeg" alt="Screenshot description" width="700"/> 
      - <img src="./IMAGES/59.jpeg" alt="Screenshot description" width="700"/> 
      - <img src="./IMAGES/60.jpeg" alt="Screenshot description" width="700"/> 
      - <img src="./IMAGES/61.jpeg" alt="Screenshot description" width="700"/> 

--- 



## **Lambda function Code Explanation**

1. **Import Statements**


```python
import boto3
import requests
import json
import time
import logging
import base64
import uuid
from botocore.exceptions import ClientError

```

---
**The above lines import the libraries and modules used in the code:**

- **boto3:** The AWS SDK for Python, used here to interact with AWS services like S3 and Textract.
- **requests:** Used to send HTTP requests, specifically to the Hugging Face API in this script.
- **json:** Provides functionality to parse JSON (JavaScript Object Notation) data, which is used for encoding and decoding JSON format.
- **time:** Provides functions to manage timing and delays in the code.
- **logging:** Allows for logging messages for debugging or tracking purposes.
- **base64:** Provides functions to encode and decode data in Base64 format, which is used to handle files as text.
- **uuid:** Used to generate unique identifiers.
- **ClientError:** A specific error from botocore (a core library for boto3) for handling errors from AWS services.
---

2. **Logging Setup**


```python
logger = logging.getLogger()
logger.setLevel(logging.INFO)
```

---
- **logging.getLogger():** Retrieves a logger instance, allowing messages to be logged.
- **logger.setLevel(logging.INFO):** Sets the logging level to INFO, meaning the logger will capture and display informational messages and above (like warnings and errors).
---

3. **Helper Function: Error Response**



```python
def create_error_response(status_code, error_message, error_details=None):
    body = {
        'error': str(error_message),
        'details': error_details if error_details else str(error_message)
    }
    return {
        'statusCode': status_code,
        'headers': {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*'
        },
        'body': json.dumps(body)
    }
```

---
- **This function creates a formatted error response to return when an error occurs:**

- **status_code:** HTTP status code (e.g., 400 for bad requests, 500 for server errors).
- **error_message:** Describes the error.
- **error_details:** Optional details for the error.
- **The function returns a dictionary with keys:**
- **'statusCode':** The HTTP status code.
- **'headers':** HTTP headers, including Content-Type and Access-Control-Allow-Origin.
- **'body':** The error details in JSON format.
---

4. **Main Function: Lambda Handler**


```python
def lambda_handler(event, context):
```

---
- **This is the main function called when the Lambda function is triggered. It takes two parameters:**

- **event:** Contains data about the request.
- **context:** Provides runtime information (often not used here).
---

## **Step-by-Step Explanation of the Lambda Handler**
5. **Logging the Incoming Event**


```python
logger.info(f"Incoming event: {json.dumps(event)}")
```

---
- Logs the entire event data for debugging, which is useful for tracking incoming requests.
---

6. **Parsing the Request Body**


```python
try:
    body = json.loads(event.get('body', '{}'))
except json.JSONDecodeError as e:
    return create_error_response(400, "Invalid JSON in request body")
```

---
- Attempts to parse the requestâ€™s body from JSON format. If itâ€™s invalid JSON, it returns a 400 error response.
---

7. **Extracting and Validating Parameters**


```python
bucket_name = 'xyz'
pdf_base64 = body.get('pdf_base64')
question = body.get('question')
```

---
- **bucket_name:** Specifies the S3 bucket name where files will be uploaded.
- **pdf_base64:** Retrieves the base64-encoded PDF file from the request body.
- **question:** Retrieves the userâ€™s question.
---


```python
if not all([pdf_base64, question]):
    missing_params = []
    if not pdf_base64: missing_params.append('pdf_base64')
    if not question: missing_params.append('question')
    return create_error_response(400, f"Missing required parameters: {', '.join(missing_params)}")
```

---
- Checks if both pdf_base64 and question were provided.
- If any required parameter is missing, it returns a 400 error with a message indicating which parameters are missing.
---

8. **Generating a Unique Key for the PDF File**


```python
pdf_key = f"uploads/{uuid.uuid4()}.pdf"
```

---
- Creates a unique key (path) for the PDF file using uuid.uuid4() to ensure each uploaded file has a distinct name.
---

9. **Uploading PDF to S3**


```python
s3_client = boto3.client('s3')
try:
    pdf_data = base64.b64decode(pdf_base64)
    s3_client.put_object(Bucket=bucket_name, Key=pdf_key, Body=pdf_data)
    logger.info("Successfully uploaded PDF to S3")
except ClientError as e:
    return create_error_response(500, f"S3 upload error: {str(e)}")
```

---
- **s3_client:** Creates an S3 client.
- **pdf_data:** Decodes the base64-encoded PDF into binary data.
- **put_object:** Uploads the decoded PDF to S3.
If an error occurs, it returns a 500 error with details.
---

10. **Starting Textract Processing**


```python
textract_client = boto3.client('textract')
start_response = textract_client.start_document_text_detection(
    DocumentLocation={'S3Object': {'Bucket': bucket_name, 'Name': pdf_key}}
)
job_id = start_response['JobId']
logger.info(f"Started Textract job: {job_id}")
```

---
- **textract_client:** Creates a Textract client.
- **start_document_text_detection:** Starts a text extraction job on the PDF file in S3.
- **job_id:** Stores the job ID returned by Textract for tracking.
---

11. **Waiting for Textract Job Completion**


```python
text = ""
max_retries = 12  # 1 minute total (5 seconds * 12)
for attempt in range(max_retries):
    job_status = textract_client.get_document_text_detection(JobId=job_id)
    status = job_status['JobStatus']
    logger.info(f"Textract job status: {status} (attempt {attempt + 1})")
```

---
- **text:** Initializes an empty string for storing extracted text.
- **max_retries:** Limits retries (12 attempts with 5-second intervals).
- **get_document_text_detection:** Checks job status. If status is:
    - **"SUCCEEDED":** Proceeds to extract text.
    - **"FAILED":** Returns a 500 error.
- If neither, it waits for 5 seconds before retrying.
---

12. **Extracting Text from Textract**


```python
pages_text = []
next_token = None

while True:
    if next_token:
        response = textract_client.get_document_text_detection(JobId=job_id, NextToken=next_token)
    else:
        response = job_status
    for block in response.get('Blocks', []):
        if block.get('BlockType') == 'LINE':
            pages_text.append(block.get('Text', ''))
    next_token = response.get('NextToken')
    if not next_token:
        break

text = " ".join(pages_text)
logger.info(f"Extracted text length: {len(text)}")
```

---
- **pages_text:** Stores lines of extracted text.
- **next_token:** Handles pagination for large documents.
- The loop iterates over each Block of text until there are no more pages.
- **text:** Joins all lines into a single string for the full document.
---

13. **Calling Hugging Face API for Answer Generation**


```python
api_url = "YOUR_API_URL_HERE"
headers = {
    "Authorization": "Bearer YOUR_HUGGING_FACE_API_KEY_HERE",
    "Content-Type": "application/json"
}
text_chunk = text[:max_context_length]
prompt = f"Provide a detailed answer to the following question based on the context. Only respond with the answer, without any additional questions.\n\nContext: {text_chunk}\n\nQuestion: {question}\n\nAnswer:"
api_response = requests.post(
    api_url,
    headers=headers,
    json={
        "inputs": prompt,
        "parameters": {
            "max_length": 500,
            "temperature": 0.7
        }
    },
    timeout=30
)
```

---
- Sets **api_url** and **headers** with authorization for Hugging Face.
- Limits **text_chunk** to fit model constraints.
- **requests.post:** Sends the request to Hugging Face, expecting a JSON response.
---

14. **Parsing the Hugging Face API Response**


```python
if api_response.status_code != 200:
    return create_error_response(500, f"Hugging Face API error: {api_response.text}")

response_data = api_response.json()
if isinstance(response_data, list):
    answer = response_data[0].get('generated_text', 'No answer found')
else:
    answer = response_data.get('generated_text', 'No answer found')

answer = answer.replace(prompt, '').strip()
```

---
- Checks for successful response; if unsuccessful, returns a 500 error.
- Parses JSON response for generated_text, removing the prompt from the answer.
---

15. **Deleting PDF from S3**


```python
try:
    s3_client.delete_object(Bucket=bucket_name, Key=pdf_key)
    logger.info(f"Deleted PDF from S3: {pdf_key}")
except ClientError as e:
    logger.error(f"Error deleting PDF from S3: {str(e)}")
```

---
- Attempts to delete the uploaded PDF from S3 after processing to avoid storage costs.
---

16. **Returning the Successful Response**


```python
return {
    'statusCode': 200,
    'headers': {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*'
    },
    'body': json.dumps({
        'question': question,
        'answer': answer,
        'textPreview': text[:200] + "..." if len(text) > 200 else text
    })
}
```

---
- **If all processes are successful, the function returns:**

- **statusCode:** 200, indicating success.
- **body:** A JSON object with the question, answer, and preview text from the document.
---

## External File for Web Interface Code
This is an html template which we are importing in our web interface file.


```python
user_template = '''
<div class="chat-message user">
    <div class="avatar">
        ðŸŽ“
    </div>    
    <div style="padding:">
    <div class="message">{{MSG}}</div>
    </div>
</div>
'''
```

## **Providing Web Interface using Streamlit (Code explanation)**

**1. Import Required Libraries**


```python
import streamlit as st
import requests
import base64
from htmltemp import user_template
import time
```

---
- **Imports:**
- streamlit is used for building the web interface.
- requests handles HTTP requests to the API.
- base64 encodes the PDF content to send it to the API.
- htmltemp imports user_template, presumably an HTML template used for formatting.
- time is used for creating a delay in the typewriter effect.
---

**2. Typewriter Function**


```python
def typewriter(text, template, speed):
    tokens = text.split()
    container = st.empty()
    for index in range(len(tokens) + 1):
        curr_full_text = " ".join(tokens[:index])
        container.markdown(curr_full_text)
        time.sleep(1 / speed)
```

---
- **typewriter function:** Displays text in a typewriter effect.
    - **Parameters:**
        - text: the text to display.
        - template: an HTML template for custom styling.
        - speed: speed of the typewriter effect.
    - **Process:**
        - Splits text into individual words.
        - Iteratively displays the cumulative words with a delay to create a typing animation effect.
        - Uses st.empty() to hold a dynamic content container in Streamlit.
---

**3. Define the RAG Pipeline API URL**


```python
api_url = "link to your api_url"
```

---
- This line stores the API endpoint URL in the variable api_url. This URL points to the RAG pipeline API, which will process the PDF content and return answers based on the input question.
---

**4. Define Streamlit App Title and Instructions**


```python
st.title("PDF Chat - RAG Pipeline")
st.write("Upload a PDF and enter a question to get answers based on the PDF content.")
```

---
- **st.title ("PDF Chat - RAG Pipeline") :** This sets the title of the Streamlit web application to "PDF Chat - RAG Pipeline," displayed at the top of the app.
- **st.write(...):** This line displays a brief instruction to guide the user on how to use the app.
---

**5. Create a File Uploader for PDFs**


```python
uploaded_pdf = st.file_uploader("Choose a PDF file", type="pdf")
```

---
- **st.file_uploader ("Choose a PDF file", type="pdf"):** This creates a file uploader in the Streamlit app that allows users to upload files.
    - "Choose a PDF file" is the text displayed next to the file uploader.
    - type="pdf" restricts uploads to PDF files only.
- **uploaded_pdf:** The variable holds the uploaded file object. If no file is uploaded, it will be None.
---

**6. Text Input for Question**


```python
question = st.text_input("Question")
```

---
- **st.text_input("Question"):** This line creates a text input field where users can type in their question.
    - "Question" is the label next to the input box.
- **question:** The variable will contain the text entered by the user. If no question is entered, it will be an empty string ("").
---

**7. Create a Button to Trigger Answer Retrieval**


```python
if st.button("Get Answer"):
```

---
- **st.button ("Get Answer"):** This line creates a button labeled "Get Answer." When clicked, it triggers the code inside the if block to run.
---

**8. Check if Both PDF and Question are Provided**


```python
if uploaded_pdf and question:
```

---
- **if uploaded_pdf and question:** This checks if both uploaded_pdf and question are available.
    - If both are provided, the code inside this if block executes.
    - If either is missing, it skips to the else block, displaying a warning to the user.
---

**9. Convert PDF to Base64 Encoding**


```python
pdf_base64 = base64.b64encode(uploaded_pdf.read()).decode("utf-8")
```

---
- **uploaded_pdf.read():** Reads the binary content of the uploaded PDF file.
- **base64.b64encode(...).decode("utf-8"):** Encodes the PDF binary data into a base64 string.
    - .decode("utf-8") converts the base64 bytes into a UTF-8 string, making it compatible with JSON.
---

**10. Create JSON Payload for API Request**


```python
payload = {
    "pdf_base64": pdf_base64,
    "question": question
}
```

---
- This creates a dictionary called payload, which will be sent to the RAG API.
    - "pdf_base64" holds the base64-encoded string of the PDF content.
    - "question" holds the user-entered question.
---

**11. Send Request to the RAG Pipeline API**


```python
response = requests.post(api_url, json=payload)
```

---
- **requests.post (api_url, json=payload):** This sends an HTTP POST request to the API URL (api_url).
    - json=payload sends the payload dictionary as a JSON object.
- **response:** This variable stores the response received from the API, which contains the answer or an error message.

**12. Display the API Response**


```python
if response.status_code == 200:
    answer = response.json().get("answer", "No answer found.")
    st.write("### Answer:")
    st.write(answer)
    typewriter(answer, user_template, 10)
    st.success("Done!")
```

---
- **if response.status_code == 200::** Checks if the API returned a success status code (200). If so, the code within this block runs.
    - **response.json().get ("answer", "No answer found."):** Parses the JSON response to retrieve the "answer" field. If the field is missing, it defaults to "No answer found.".
    - **st.write ("### Answer:"):** Displays "Answer" as a subheader in Markdown format.
    - **st.write(answer):** Displays the retrieved answer below the subheader.
    - Displays the answer using the typewriter effect.
    - **st.success("Done!"):** Shows a success message once the answer is displayed.
---

**13. Error Handling for Non-200 Status Codes**


```python
else:
    st.error("Error retrieving answer. Please try again.")
```

---
- **st.error(...):** Displays an error message if the API response status code is not 200, indicating an issue in retrieving the answer.
---

**14. Warning if PDF or Question is Missing**


```python
else:
    st.warning("Please upload a PDF and enter a question.")
```

## OUTPUT
- Ouput can be generated by writing **streamlit run  file_name.py** command in terminal.
- you just need to run your web interface code file by writing the above command, your lambda function code file is to be deployed on AWS LAMBDA FUNCTION as discussed earlier.
    - <img src="./IMAGES/62.png" alt="Screenshot description" width="700"/> 

## Usage

### Request Format

The Lambda function expects a POST request with a JSON body containing:

- **pdf_base64**: Base64-encoded string of the PDF document.
- **question**: The question to be answered based on the document text.

Example request format:
```json
{
  "pdf_base64": "base64_encoded_pdf_data",
  "question": "What is the main topic discussed in the document?"
}
```

### Response Format

The Lambda function returns a JSON response with:
- **question**: The original question.
- **answer**: The answer generated by the Hugging Face model based on the document text.
- **textPreview**: A preview of the first 200 characters of the extracted text.

Example response format:
```json
{
  "question": "What is the main topic discussed in the document?",
  "answer": "The main topic is...",
  "textPreview": "This document discusses ..."
}
```

### Error Handling

In case of errors (e.g., missing parameters, Textract processing failure, or Hugging Face API errors), the function returns an error response with an HTTP status code and a message describing the issue.

Example error response:
```json
{
  "statusCode": 400,
  "headers": {
    "Content-Type": "application/json",
    "Access-Control-Allow-Origin": "*"
  },
  "body": {
    "error": "Invalid JSON in request body",
    "details": "The provided request body is not a valid JSON."
  }
}
```

## Explanation of Main Components

1. **Text Extraction with Amazon Textract**:
   - The function initiates a text detection job for the uploaded PDF.
   - It checks job status periodically until completion.
   - Once completed, the text is extracted and compiled for processing.

2. **Answer Generation with Hugging Face**:
   - The extracted text is passed along with the question to a Hugging Face model endpoint.
   - The function formats the prompt and retrieves the answer.

3. **S3 Cleanup**:
   - After processing, the uploaded PDF file is deleted from the S3 bucket to save storage costs.

## Logging and Monitoring

The function uses logging to monitor progress and track errors:
- **INFO Logs**: Show events such as incoming requests, successful file uploads, job status, etc.
- **ERROR Logs**: Capture issues like S3 upload failures or Textract errors.

You can view these logs in AWS CloudWatch.

## Security Considerations

- Use AWS Identity and Access Management (IAM) to secure permissions for S3 and Textract.
- Store sensitive information, such as the Hugging Face API key, securely (e.g., in AWS Secrets Manager or Lambda environment variables).
- Enable encryption for your S3 bucket to protect uploaded PDF files.

## License

This project is provided under the MIT License. See `LICENSE` for details.


